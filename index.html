<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>QR Capture & Crop (OpenCV.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }

    body {
      margin: 0;
      padding: 12px;
      background: #0b0b0b;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
    }

    .container {
      width: 100%;
      max-width: 480px;
    }

    h2 {
      margin: 0 0 6px 0;
      font-size: 1.2rem;
      text-align: center;
    }

    p {
      margin: 0 0 10px 0;
      font-size: 0.9rem;
      text-align: center;
      color: #c2c2c2;
    }

    #video {
      width: 100%;
      height: auto;
      aspect-ratio: 4 / 3;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      display: block;
    }

    #controls {
      margin: 10px 0 10px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
    }

    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px;
      font-size: 0.9rem;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      flex: 1;
      min-width: 0;
    }

    #captureBtn {
      background: #1e88e5;
      color: #fff;
    }

    #captureBtn:active {
      transform: scale(0.97);
      background: #1565c0;
    }

    #captureBtn:disabled {
      background: #555;
      cursor: default;
      transform: none;
    }

    #flashBtn {
      background: #333;
      color: #f5f5f5;
    }

    #flashBtn.enabled {
      background: #ffd54f;
      color: #000;
    }

    #flashBtn:active,
    #photoBtn:active {
      transform: scale(0.97);
    }

    #photoBtn {
      background: #4caf50;
      color: #fff;
    }

    #photoBtn:disabled {
      background: #555;
      cursor: default;
      transform: none;
    }

    #base64Btn {
      background: #9c27b0;
      color: #fff;
    }

    #base64Btn:disabled {
      background: #555;
      cursor: default;
    }

    #copyBase64Btn {
      background: #607d8b;
      color: #fff;
    }

    #copyBase64Btn:disabled {
      background: #555;
      cursor: default;
    }

    #status {
      font-size: 0.8rem;
      text-align: center;
      color: #bbbbbb;
      min-height: 1.2rem;
    }

    #tapHint {
      font-size: 0.75rem;
      text-align: center;
      color: #888;
    }

    #output {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 4px;
    }

    .panel {
      background: #151515;
      padding: 8px;
      border-radius: 10px;
    }

    .panel-title {
      font-size: 0.85rem;
      margin-bottom: 4px;
      color: #d0d0d0;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      border: 1px solid #333;
      background: #000;
      display: block;
    }

    #base64Output {
      width: 100%;
      min-height: 100px;
      max-height: 240px;
      resize: vertical;
      font-size: 0.7rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #050505;
      color: #e0e0e0;
      border-radius: 8px;
      border: 1px solid #333;
      padding: 6px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>QR Capture & Crop</h2>
    <p>Choose: live camera or take a photo, then process the QR.</p>

    <!-- Live camera -->
    <video id="video" autoplay playsinline></video>

    <!-- Controls -->
    <div id="controls">
      <div class="button-row">
        <button id="captureBtn" disabled>Capture (Live)</button>
        <button id="flashBtn" disabled>Flash</button>
      </div>
      <div class="button-row">
        <button id="photoBtn">Use Photo / Take Photo</button>
      </div>
      <div class="button-row">
        <button id="base64Btn" disabled>Get Base64 (Center 36% Clean)</button>
        <button id="copyBase64Btn" disabled>Copy Base64</button>
      </div>
      <span id="status">Loading OpenCV…</span>
      <div id="tapHint">Tip: tap the video to refocus (if supported).</div>
    </div>

    <!-- Base64 output area -->
    <div class="panel">
      <div class="panel-title">Base64 (Center 36% Cleaned Crop)</div>
      <textarea id="base64Output" placeholder="Click the button above after a QR is processed to see Base64 here."></textarea>
    </div>

    <!-- Hidden canvas -->
    <canvas id="hiddenCanvas" style="display:none;"></canvas>

    <!-- Hidden file input -->
    <input
      type="file"
      id="photoInput"
      accept="image/*"
      capture="environment"
      style="display:none;"
    />

    <!-- Output canvases -->
    <div id="output">
      <div class="panel">
        <div class="panel-title">Full QR Crop (Siamese-clean)</div>
        <canvas id="qrFull"></canvas>
      </div>
      <div class="panel">
        <div class="panel-title">Center 36% Crop (Siamese-clean)</div>
        <canvas id="qrCenter"></canvas>
      </div>
      <div class="panel">
        <div class="panel-title">Straight QR (Siamese-clean)</div>
        <canvas id="qrStraight"></canvas>
      </div>
    </div>
  </div>

  <!-- Main JS -->
  <script>
    let video = document.getElementById('video');
    let hiddenCanvas = document.getElementById('hiddenCanvas');

    let qrFullCanvas = document.getElementById('qrFull');
    let qrCenterCanvas = document.getElementById('qrCenter');
    let qrStraightCanvas = document.getElementById('qrStraight');

    let captureBtn = document.getElementById('captureBtn');
    let flashBtn = document.getElementById('flashBtn');
    let photoBtn = document.getElementById('photoBtn');
    let base64Btn = document.getElementById('base64Btn');
    let copyBase64Btn = document.getElementById('copyBase64Btn');
    let photoInput = document.getElementById('photoInput');
    let statusSpan = document.getElementById('status');
    let base64Output = document.getElementById('base64Output');

    let qrDetector = null;
    let streaming = false;
    let opencvReady = false;

    let videoTrack = null;
    let torchAvailable = false;
    let torchOn = false;
    let focusSupported = false;

    // keep last decoded string and qr_id
    let lastDecoded = null;
    let lastQrId = null;

    // helper to extract qr_id from decoded URL/text
    function extractQrId(decoded) {
      if (!decoded) return null;

      // Try URL parsing first
      try {
        if (decoded.startsWith('http://') || decoded.startsWith('https://')) {
          const url = new URL(decoded);
          const id = url.searchParams.get('qr_id');
          if (id) return id;
        }
      } catch (e) {
        console.warn('URL parse failed for decoded QR:', e);
      }

      // Fallback: regex search in raw string
      let match = decoded.match(/[?&]qr_id=([^&]+)/);
      if (!match) {
        match = decoded.match(/qr_id=([^&]+)/);
      }
      return match ? decodeURIComponent(match[1]) : null;
    }

    // === Base64 button: use CENTER 36% canvas ===
    base64Btn.addEventListener('click', async () => {
      const canvas = qrCenterCanvas; // center 36% cleaned crop

      if (!canvas.width || !canvas.height) {
        alert('No center crop available yet.');
        return;
      }

      const base64 = canvas.toDataURL('image/png');
      base64Output.value = base64; // show on page
      base64Output.scrollTop = 0;
      copyBase64Btn.disabled = !base64; // enable copy if we have something

      // prepare payload for API call
      const imageBase64Clean = base64.replace(/^data:image\/\w+;base64,/, '');

      const qrId = lastQrId || extractQrId(lastDecoded);
      if (!qrId) {
        console.warn('qr_id not found in decoded QR data:', lastDecoded);
        statusSpan.textContent = 'qr_id not found in QR data.';
        alert('qr_id not found in QR data.');
        return;
      }

      const payload = {
        id: qrId,
        image_base64: imageBase64Clean
      };

      console.log('Sending payload to API:', payload);

      try {
        const response = await fetch(
          'https://9ahp0tc529.execute-api.ap-south-1.amazonaws.com/dev',
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          }
        );

        if (!response.ok) {
          console.error('API error status:', response.status);
          statusSpan.textContent = 'API error: ' + response.status;
          alert('API error: ' + response.status);
        } else {
          let data = null;
          let text = null;
          try {
            // try JSON first
            data = await response.json();
          } catch (e) {
            // if not JSON, fallback to text
            try {
              text = await response.text();
            } catch (e2) {}
          }

          console.log('API success response:', data || text);
          statusSpan.textContent = 'QR data sent to server.';

          // *** ALERT TEST VERDICT HERE ***
          if (data && data.test_verdict) {
            alert(
              'Test verdict:\n' +
              JSON.stringify(data.test_verdict, null, 2)
            );
          } else if (data) {
            alert(
              'API response (no test_verdict field found):\n' +
              JSON.stringify(data, null, 2)
            );
          } else if (text) {
            alert('API response (non-JSON):\n' + text);
          } else {
            alert('API call succeeded, but response is empty.');
          }
        }
      } catch (err) {
        console.error('API call failed:', err);
        statusSpan.textContent = 'API call failed: ' + err.message;
        alert('API call failed: ' + err.message);
      }
    });

    // === Copy Base64 button ===
    copyBase64Btn.addEventListener('click', () => {
      const text = base64Output.value;
      if (!text.trim()) {
        alert('No Base64 string to copy.');
        return;
      }

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text)
          .then(() => {
            // optional feedback
            // alert('Base64 copied to clipboard.');
          })
          .catch(err => {
            console.error('Clipboard error:', err);
            alert('Could not copy to clipboard. You can still copy manually.');
          });
      } else {
        alert('Clipboard API not supported. Please copy manually.');
      }
    });

    // === Camera ===
    function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        console.warn("Camera not supported. Live mode disabled, photo mode still works.");
        statusSpan.textContent = "Camera not supported (use Photo mode).";
        captureBtn.disabled = true;
        flashBtn.disabled = true;
        return;
      }

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width:  { ideal: 2560 },
          height: { ideal: 1440 }
        },
        audio: false
      };

      navigator.mediaDevices.getUserMedia(constraints)
        .then(stream => {
          videoTrack = stream.getVideoTracks()[0];

          const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
          console.log('Video capabilities:', caps);

          if ('torch' in caps) {
            torchAvailable = true;
            flashBtn.disabled = false;
            flashBtn.textContent = "Flash Off";
          } else {
            torchAvailable = false;
            flashBtn.disabled = true;
            flashBtn.textContent = "Flash N/A";
          }

          if (caps.focusMode && caps.focusMode.length > 0) {
            focusSupported = true;
          }

          const settings = videoTrack.getSettings ? videoTrack.getSettings() : {};
          console.log("Camera settings:", settings);
          statusSpan.textContent = `Camera started: ${settings.width || ''}×${settings.height || ''}`.trim();

          video.srcObject = stream;
          video.play();
        })
        .catch(err => {
          console.error("Error accessing camera: ", err);
          alert("Could not access camera: " + err.message);
          statusSpan.textContent = "Camera error. You can still use Photo mode.";
          captureBtn.disabled = true;
          flashBtn.disabled = true;
        });
    }

    // === Siamese-style cleaning ===
    function siameseClean(mat) {
      // Ensure 8-bit 3-channel BGR
      let bgr = new cv.Mat();
      if (mat.type() !== cv.CV_8UC3) {
        mat.convertTo(bgr, cv.CV_8U);
        if (bgr.channels() === 4) {
          let tmp = new cv.Mat();
          cv.cvtColor(bgr, tmp, cv.COLOR_RGBA2BGR);
          bgr.delete();
          bgr = tmp;
        } else if (bgr.channels() === 1) {
          let tmp = new cv.Mat();
          cv.cvtColor(bgr, tmp, cv.COLOR_GRAY2BGR);
          bgr.delete();
          bgr = tmp;
        }
      } else {
        bgr = mat.clone();
      }

      // BGR -> Gray
      let gray = new cv.Mat();
      cv.cvtColor(bgr, gray, cv.COLOR_BGR2GRAY);

      // Very light blur (5x5, sigma=0.7, REFLECT_101)
      let blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0.7, 0.7, cv.BORDER_REFLECT_101);

      // Normalize in float then bring back to 8U
      let blurred32 = new cv.Mat();
      blurred.convertTo(blurred32, cv.CV_32F);

      let norm32 = new cv.Mat();
      cv.normalize(blurred32, norm32, 0, 255, cv.NORM_MINMAX);

      let norm8 = new cv.Mat();
      norm32.convertTo(norm8, cv.CV_8U);

      // Back to 3-channel so cv.imshow + canvases behave consistently
      let cleaned3 = new cv.Mat();
      cv.cvtColor(norm8, cleaned3, cv.COLOR_GRAY2BGR);

      // Clean up intermediates
      bgr.delete();
      gray.delete();
      blurred.delete();
      blurred32.delete();
      norm32.delete();
      norm8.delete();

      return cleaned3;
    }

    // === Core QR processing ===
    function processMat(src) {
      if (!qrDetector) {
        qrDetector = new cv.QRCodeDetector();
      }

      let points = new cv.Mat();
      let straight = new cv.Mat();
      let decoded = qrDetector.detectAndDecode(src, points, straight);

      if (decoded && decoded.length > 0 && !points.empty()) {
        console.log('QR data:', decoded);
        statusSpan.textContent = "QR detected: " + decoded;

        // store last decoded and qr_id
        lastDecoded = decoded;
        lastQrId = extractQrId(decoded);
        console.log('Extracted qr_id:', lastQrId);

        let data = points.data32F;
        let xs = [data[0], data[2], data[4], data[6]];
        let ys = [data[1], data[3], data[5], data[7]];

        let xMin = parseInt(Math.min(...xs));
        let xMax = parseInt(Math.max(...xs));
        let yMin = parseInt(Math.min(...ys));
        let yMax = parseInt(Math.max(...ys));

        const pad = 4;
        xMin = Math.max(0, xMin - pad);
        yMin = Math.max(0, yMin - pad);
        xMax = Math.min(src.cols, xMax + pad);
        yMax = Math.min(src.rows, yMax + pad);

        let width = xMax - xMin;
        let height = yMax - yMin;

        if (width > 0 && height > 0) {
          // (A) QR crop
          let rect = new cv.Rect(xMin, yMin, width, height);
          let qrCrop = src.roi(rect);

          // (B) full clean
          let qrClean = siameseClean(qrCrop);
          cv.imshow('qrFull', qrClean);

          // (C) center 36% crop
          let h = qrCrop.rows;
          let w = qrCrop.cols;
          let cropW = Math.floor(w * 0.36);
          let cropH = Math.floor(h * 0.36);

          let cx = Math.floor(w / 2);
          let cy = Math.floor(h / 2);

          let x1 = cx - Math.floor(cropW / 2);
          let y1 = cy - Math.floor(cropH / 2);
          let x2 = x1 + cropW;
          let y2 = y1 + cropH;

          x1 = Math.max(0, x1);
          y1 = Math.max(0, y1);
          x2 = Math.min(w, x2);
          y2 = Math.min(h, y2);

          let centerW = x2 - x1;
          let centerH = y2 - y1;

          if (centerW > 0 && centerH > 0) {
            let centerRect = new cv.Rect(x1, y1, centerW, centerH);
            let centerCrop = qrCrop.roi(centerRect);

            let centerClean = siameseClean(centerCrop);
            cv.imshow('qrCenter', centerClean);

            // enable Base64 + copy buttons
            base64Btn.disabled = false;
            copyBase64Btn.disabled = !base64Output.value.trim();

            centerClean.delete();
            centerCrop.delete();
          } else {
            base64Btn.disabled = true;
            copyBase64Btn.disabled = true;
          }

          qrClean.delete();
          qrCrop.delete();
        } else {
          statusSpan.textContent = "QR detected but crop size invalid.";
          base64Btn.disabled = true;
          copyBase64Btn.disabled = true;
        }

        // (E) straight QR
        if (!straight.empty()) {
          let straightMat = straight.clone();

          if (straightMat.channels() === 1) {
            let rgb = new cv.Mat();
            cv.cvtColor(straightMat, rgb, cv.COLOR_GRAY2BGR);
            straightMat.delete();
            straightMat = rgb;
          }

          let straightClean = siameseClean(straightMat);
          cv.imshow('qrStraight', straightClean);

          straightClean.delete();
          straightMat.delete();
        } else {
          let ctx = qrStraightCanvas.getContext('2d');
          ctx.clearRect(0, 0, qrStraightCanvas.width, qrStraightCanvas.height);
        }
      } else {
        console.log("No QR code detected.");
        statusSpan.textContent = "No QR detected. Try again / move closer.";
        base64Btn.disabled = true;
        copyBase64Btn.disabled = true;
      }

      points.delete();
      straight.delete();
    }

    // === Capture from live video ===
    function captureFromVideo() {
      if (!opencvReady || !streaming) {
        alert("Live camera not ready yet.");
        return;
      }

      const w = hiddenCanvas.width;
      const h = hiddenCanvas.height;
      const ctx = hiddenCanvas.getContext('2d');

      ctx.drawImage(video, 0, 0, w, h);

      let src = cv.imread(hiddenCanvas);
      let bgr = new cv.Mat();
      cv.cvtColor(src, bgr, cv.COLOR_RGBA2BGR);
      src.delete();

      processMat(bgr);
      bgr.delete();
    }

    // === Handle photo selection ===
    function handlePhotoSelection(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      if (!opencvReady) {
        alert("OpenCV not ready.");
        return;
      }

      const img = new Image();
      const url = URL.createObjectURL(file);

      img.onload = () => {
        hiddenCanvas.width = img.width;
        hiddenCanvas.height = img.height;

        const ctx = hiddenCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        let src = cv.imread(hiddenCanvas);
        let bgr = new cv.Mat();
        cv.cvtColor(src, bgr, cv.COLOR_RGBA2BGR);
        src.delete();

        processMat(bgr);
        bgr.delete();

        URL.revokeObjectURL(url);
        photoInput.value = "";
      };

      img.onerror = () => {
        alert("Failed to load image.");
        URL.revokeObjectURL(url);
      };

      img.src = url;
    }

    // === Called once OpenCV runtime is ready ===
    function onOpenCvReady() {
      console.log('OpenCV.js runtime ready');
      opencvReady = true;
      statusSpan.textContent = "OpenCV ready. Starting live camera…";

      startCamera();

      video.addEventListener('playing', () => {
        if (streaming) return;
        streaming = true;

        if (video.videoWidth === 0 || video.videoHeight === 0) return;

        hiddenCanvas.width = video.videoWidth;
        hiddenCanvas.height = video.videoHeight;

        console.log("Video element size:", video.videoWidth, "x", video.videoHeight);

        qrDetector = new cv.QRCodeDetector();
        captureBtn.disabled = false;
        statusSpan.textContent = `Live mode ready (${video.videoWidth}×${video.videoHeight}). Or use Photo mode.`;
      });

      // buttons
      captureBtn.addEventListener('click', captureFromVideo);
      flashBtn.addEventListener('click', () => {
        if (!videoTrack || !videoTrack.applyConstraints || !torchAvailable) {
          alert("Flash/torch not supported on this device or browser.");
          return;
        }
        torchOn = !torchOn;
        videoTrack.applyConstraints({ advanced: [{ torch: torchOn }] })
          .then(() => {
            flashBtn.classList.toggle('enabled', torchOn);
            flashBtn.textContent = torchOn ? "Flash On" : "Flash Off";
          })
          .catch(err => {
            console.error("Error toggling torch:", err);
            alert("Could not toggle flash: " + err.message);
          });
      });

      video.addEventListener('click', () => {
        if (!videoTrack || !videoTrack.applyConstraints || !focusSupported) return;
        videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] })
          .then(() => console.log("Requested re-focus (continuous)."))
          .catch(err => console.warn("Focus constraint error:", err));
      });

      photoBtn.addEventListener('click', () => {
        if (!opencvReady) {
          alert("OpenCV not ready yet.");
          return;
        }
        photoInput.click();
      });

      photoInput.addEventListener('change', handlePhotoSelection);
    }
  </script>

  <!-- OpenCV.js with runtime hook -->
  <script>
    var Module = {
      onRuntimeInitialized() {
        onOpenCvReady();
      }
    };
  </script>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
</body>
</html>
