<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>QR Capture & Crop (OpenCV.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }

    body {
      margin: 0;
      padding: 12px;
      background: #0b0b0b;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
    }

    .container {
      width: 100%;
      max-width: 480px;
    }

    h2 {
      margin: 0 0 6px 0;
      font-size: 1.2rem;
      text-align: center;
    }

    p {
      margin: 0 0 10px 0;
      font-size: 0.9rem;
      text-align: center;
      color: #c2c2c2;
    }

    #video {
      width: 100%;
      height: auto;
      aspect-ratio: 4 / 3;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      display: block;
    }

    #controls {
      margin: 10px 0 14px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
    }

    .button-row {
      display: flex;
      gap: 8px;
    }

    button {
      padding: 10px;
      font-size: 0.9rem;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      flex: 1;
    }

    #captureBtn {
      background: #1e88e5;
      color: #fff;
    }

    #captureBtn:active {
      transform: scale(0.97);
      background: #1565c0;
    }

    #captureBtn:disabled {
      background: #555;
      cursor: default;
      transform: none;
    }

    #flashBtn {
      background: #333;
      color: #f5f5f5;
    }

    #flashBtn.enabled {
      background: #ffd54f;
      color: #000;
    }

    #flashBtn:active {
      transform: scale(0.97);
    }

    #status {
      font-size: 0.8rem;
      text-align: center;
      color: #bbbbbb;
      min-height: 1.2rem;
    }

    #tapHint {
      font-size: 0.75rem;
      text-align: center;
      color: #888;
    }

    #output {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 4px;
    }

    .panel {
      background: #151515;
      padding: 8px;
      border-radius: 10px;
    }

    .panel-title {
      font-size: 0.85rem;
      margin-bottom: 4px;
      color: #d0d0d0;
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      border: 1px solid #333;
      background: #000;
      display: block;
    }

    @media (min-width: 700px) {
      #output {
        flex-direction: row;
      }
      .panel {
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>QR Capture & Crop</h2>
    <p>Point your camera at a QR code, then tap <b>Capture</b>.</p>

    <!-- Live camera (tap to refocus) -->
    <video id="video" autoplay playsinline></video>

    <!-- Controls -->
    <div id="controls">
      <div class="button-row">
        <button id="captureBtn" disabled>Capture</button>
        <button id="flashBtn" disabled>Flash</button>
      </div>
      <span id="status">Loading OpenCV…</span>
      <div id="tapHint">Tip: tap the video to refocus (if supported).</div>
    </div>

    <!-- Hidden canvas to grab video frame -->
    <canvas id="hiddenCanvas" style="display:none;"></canvas>

    <!-- Output canvases -->
    <div id="output">
      <div class="panel">
        <div class="panel-title">Full QR Crop (cleaned)</div>
        <canvas id="qrFull"></canvas>
      </div>
      <div class="panel">
        <div class="panel-title">Center 36% Crop (cleaned)</div>
        <canvas id="qrCenter"></canvas>
      </div>
    </div>
  </div>

  <!-- Load OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

  <script>
    let video = document.getElementById('video');
    let hiddenCanvas = document.getElementById('hiddenCanvas');
    let qrFullCanvas = document.getElementById('qrFull');
    let qrCenterCanvas = document.getElementById('qrCenter');
    let captureBtn = document.getElementById('captureBtn');
    let flashBtn = document.getElementById('flashBtn');
    let statusSpan = document.getElementById('status');

    let qrDetector = null;
    let streaming = false;
    let opencvReady = false;

    let videoTrack = null;
    let torchAvailable = false;
    let torchOn = false;
    let focusSupported = false;

    // Ask for high-res back camera
    function startCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Camera not supported here. Use Chrome on Android and http://<ip>:8000 or HTTPS.");
        statusSpan.textContent = "Camera not supported";
        return;
      }

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width:  { ideal: 1920, max: 2560 },
          height: { ideal: 1080, max: 1440 }
        },
        audio: false
      };

      navigator.mediaDevices.getUserMedia(constraints)
        .then(stream => {
          videoTrack = stream.getVideoTracks()[0];

          // Read capabilities to see if torch / focus are supported
          const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
          console.log('Video capabilities:', caps);

          if ('torch' in caps) {
            torchAvailable = true;
            flashBtn.disabled = false;
            flashBtn.textContent = "Flash Off";
          } else {
            flashBtn.disabled = true;
            flashBtn.textContent = "Flash N/A";
          }

          if (caps.focusMode && caps.focusMode.length > 0) {
            focusSupported = true;
          }

          const settings = videoTrack.getSettings ? videoTrack.getSettings() : {};
          console.log("Camera settings:", settings);
          statusSpan.textContent = `Camera started: ${settings.width || ''}×${settings.height || ''}`.trim();

          video.srcObject = stream;
          video.play();
        })
        .catch(err => {
          console.error("Error accessing camera: ", err);
          alert("Could not access camera: " + err.message);
          statusSpan.textContent = "Camera error";
        });
    }

    function onOpenCvReady() {
      console.log('OpenCV.js loaded');
      opencvReady = true;
      statusSpan.textContent = "OpenCV ready, starting camera…";
      startCamera();

      video.addEventListener('playing', () => {
        if (streaming) return;
        streaming = true;

        const initLoop = () => {
          if (video.videoWidth === 0 || video.videoHeight === 0) {
            requestAnimationFrame(initLoop);
            return;
          }

          hiddenCanvas.width = video.videoWidth;
          hiddenCanvas.height = video.videoHeight;

          console.log("Video element size:", video.videoWidth, "x", video.videoHeight);

          qrDetector = new cv.QRCodeDetector();

          captureBtn.disabled = false;
          statusSpan.textContent = `Camera ready (${video.videoWidth}×${video.videoHeight}). Aim at QR & tap Capture.`;
        };

        initLoop();
      });

      captureBtn.addEventListener('click', captureAndProcess);
      flashBtn.addEventListener('click', toggleFlash);

      // Tap to refocus (best-effort: triggers autofocus, not region-based)
      video.addEventListener('click', () => {
        if (!videoTrack || !videoTrack.applyConstraints || !focusSupported) {
          console.log("Focus not supported on this device/browser.");
          return;
        }
        // This typically just re-triggers autofocus
        videoTrack.applyConstraints({
          advanced: [{ focusMode: 'continuous' }]
        }).then(() => {
          console.log("Requested re-focus (continuous).");
        }).catch(err => {
          console.warn("Focus constraint error:", err);
        });
      });
    }

    // Torch toggle (Android Chrome on supported devices)
    function toggleFlash() {
      if (!videoTrack || !videoTrack.applyConstraints || !torchAvailable) {
        alert("Flash/torch not supported on this device or browser.");
        return;
      }

      torchOn = !torchOn;
      videoTrack.applyConstraints({
        advanced: [{ torch: torchOn }]
      }).then(() => {
        console.log("Torch set to:", torchOn);
        flashBtn.classList.toggle('enabled', torchOn);
        flashBtn.textContent = torchOn ? "Flash On" : "Flash Off";
      }).catch(err => {
        console.error("Error toggling torch:", err);
        alert("Could not toggle flash: " + err.message);
      });
    }

    // Cleaning: light blur + contrast normalize, NO upscaling
    function cleanMat(mat) {
      let tmp = new cv.Mat();
      let cleaned = new cv.Mat();

      cv.GaussianBlur(mat, tmp, new cv.Size(3, 3), 0.4, 0.4, cv.BORDER_DEFAULT);
      cv.normalize(tmp, cleaned, 0, 255, cv.NORM_MINMAX);

      tmp.delete();
      return cleaned;
    }

    function captureAndProcess() {
      if (!opencvReady || !streaming || !qrDetector) {
        alert("Not ready yet. Wait for camera & OpenCV.");
        return;
      }

      const w = hiddenCanvas.width;
      const h = hiddenCanvas.height;
      const ctx = hiddenCanvas.getContext('2d');

      ctx.drawImage(video, 0, 0, w, h);

      let src = cv.imread(hiddenCanvas);  // CV_8UC4

      let points = new cv.Mat();
      let straight = new cv.Mat();
      let decoded = qrDetector.detectAndDecode(src, points, straight);

      if (decoded && decoded.length > 0 && !points.empty()) {
        console.log('QR data:', decoded);
        statusSpan.textContent = "QR detected: " + decoded;

        let data = points.data32F;
        let xs = [data[0], data[2], data[4], data[6]];
        let ys = [data[1], data[3], data[5], data[7]];

        let xMin = Math.max(0, Math.floor(Math.min.apply(null, xs)));
        let xMax = Math.min(src.cols, Math.ceil(Math.max.apply(null, xs)));
        let yMin = Math.max(0, Math.floor(Math.min.apply(null, ys)));
        let yMax = Math.min(src.rows, Math.ceil(Math.max.apply(null, ys)));

        let width = xMax - xMin;
        let height = yMax - yMin;

        if (width > 0 && height > 0) {
          // Full QR crop (no upscaling)
          let rect = new cv.Rect(xMin, yMin, width, height);
          let qrCrop = src.roi(rect);

          let qrClean = cleanMat(qrCrop);
          cv.imshow('qrFull', qrClean);

          // Center 36% crop
          let cw = Math.floor(width * 0.36);
          let ch = Math.floor(height * 0.36);
          let cx = Math.floor(width / 2);
          let cy = Math.floor(height / 2);

          let cx1 = Math.max(0, cx - Math.floor(cw / 2));
          let cy1 = Math.max(0, cy - Math.floor(ch / 2));
          let cx2 = Math.min(width, cx1 + cw);
          let cy2 = Math.min(height, cy1 + ch);

          let cwidth = cx2 - cx1;
          let cheight = cy2 - cy1;

          if (cwidth > 0 && cheight > 0) {
            let centerRect = new cv.Rect(cx1, cy1, cwidth, cheight);
            let centerCrop = qrCrop.roi(centerRect);

            let centerClean = cleanMat(centerCrop);
            cv.imshow('qrCenter', centerClean);

            centerClean.delete();
            centerCrop.delete();
          }

          qrClean.delete();
          qrCrop.delete();
        } else {
          statusSpan.textContent = "QR detected but crop size invalid.";
        }
      } else {
        console.log("No QR code detected in this frame.");
        statusSpan.textContent = "No QR detected. Move closer / adjust angle.";
        alert("No QR code detected in this capture. Try again.");
      }

      src.delete();
      points.delete();
      straight.delete();
    }
  </script>
</body>
</html>
